{"id":383390246,"lang":"cpp","time":"1 year, 4 months","timestamp":1597871417,"status_display":"Accepted","runtime":"200 ms","url":"/submissions/detail/383390246/","is_pending":"Not Pending","title":"Minimum Moves to Move a Box to Their Target Location","memory":"30.6 MB","code":"class Solution {\n    \n    int dx[4] = {0,1,0,-1};\n    int dy[4] = {1,0,-1,0};\n    \n    \npublic:\n    int n,m;\n    set<pair<int,int>> cnts;\n    vector<vector<int>> dp;\n    \n    bool valid(vector<vector<char>>& grid,int i,int j ){\n        if(i < 0 || j < 0 || i >=n || j>=m) return false;\n        if(grid[i][j] == '#') return false;\n        return true;\n    }\n    \n    \n    bool dfs(vector<vector<char>>&grid,int px,int py,int npx,int npy,vector<vector<int>> &vis){\n        if(!valid(grid,px,py) || vis[px][py] == 1 ) return 0;\n        vis[px][py] = 1;\n        if(px == npx && py == npy) return 1;\n        bool found = 0;\n        for(int k = 0;k<4;k++){\n            found |= dfs(grid,px+dx[k],py+dy[k],npx,npy,vis);\n        }\n        return found;\n    }\n    bool canwalk(vector<vector<char>>&grid,int px,int py,int npx,int npy){\n        vector<vector<int>> vis(n,vector<int>(m,0));\n        if(dp[px*m+py][npx*m+npy]!=-1) return dp[px*m+py][npx*m+npy];\n        if(dfs(grid,px,py,npx,npy,vis)) return dp[px*m+py][npx*m+npy] = true;\n        return dp[px*m+py][npx*m+npy] = false;\n    }\n        \n    int minPushBox(vector<vector<char>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n        \n        int S=-1,B=-1,T=-1;\n        for(int i = 0;i<n;i++){\n            for(int j = 0;j<m;j++){\n                if(grid[i][j] == 'S') {\n                    S = i*m+j;\n                    grid[i][j] ='.';\n                    cout << i << \" \" << j << endl;\n                }\n                if(grid[i][j] == 'T') {\n                    T = i*m+j;\n                    grid[i][j] ='.';\n                }\n                if(grid[i][j] == 'B') {\n                    B = i*m+j;\n                    grid[i][j] ='.';\n                }\n            }\n        }\n        \n        dp = vector<vector<int>>(m*n,vector<int>(m*n,-1));\n        queue<pair<int,int>> qq;\n        qq.push({S,B});\n        int ans = 0;\n        \n        while(qq.size()){\n            int l = qq.size();\n            \n            // cout << \"RISING SUN\" << endl;\n            for(int i = 0;i<l;i++){\n                int p = qq.front().first;\n                int b = qq.front().second;\n                qq.pop();\n                \n                \n                int px = p/m,py = p%m;\n                int bx = b/m,by = b%m;\n                \n                \n                // cout << px << \" \" << py << \" \" << bx << \" \" << by << endl;\n                if(b == T) return ans;\n                \n                for(int k = 0;k<4;k++){\n                    int nbx = bx + dx[k];\n                    int nby = by + dy[k];\n                    \n                    int npx = bx - dx[k];\n                    int npy = by - dy[k];\n                    \n                    \n                    if(valid(grid,nbx,nby) && valid(grid,npx,npy)){\n                        grid[bx][by] = '#';\n                            // cout << cw << \" \" << px << \" \" << py << \" \" << npx << \" \" << npy << endl;\n                        if(canwalk(grid,px,py,npx,npy) && cnts.count({b,nbx*m+nby}) == 0){\n                            qq.push({b,nbx*m+nby});\n                            cnts.insert({b,nbx*m+nby});\n                        }\n                        grid[bx][by] = '.';\n                    }\n                }\n            }\n            ans += 1;\n        }\n        return -1;\n    }\n};","compare_result":"111111111111111111","title_slug":"minimum-moves-to-move-a-box-to-their-target-location"}