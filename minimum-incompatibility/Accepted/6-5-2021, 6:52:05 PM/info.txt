{"id":503361874,"lang":"cpp","time":"6 months, 3 weeks","timestamp":1622899325,"status_display":"Accepted","runtime":"1084 ms","url":"/submissions/detail/503361874/","is_pending":"Not Pending","title":"Minimum Incompatibility","memory":"14.7 MB","code":"const int INF = 1e9;\n\nclass Solution {\npublic:\n    int minimumIncompatibility(vector<int>& nums, int k) {\n        int i, n = nums.size(), subset_size = n / k;\n        sort(nums.begin(), nums.end());\n        \n        // Pre-calculate the range (max - min) for each subset of nums\n\t\t// Note that there are (1 << n) subsets (i.e. 2 ^ n subsets) of an array of size n\n        vector<int> range(1 << n, INF);\n        \n        // Each mask represents every possible subset of elements in num (so, \"mask\" == \"subset\")\n\t\t// Specifically, if the bit at position i of mask is set to 1, then we include that number in the subset\n        for(int mask = 1; mask < (1 << n); mask++) {\n            int small = -1, big = -1;\n            bool dup = false;\n            \n            // Identify elements that belong to this subset, find the largest & smallest, check for duplicates\n\t\t\t// Recall that this array was sorted in the beginning of the function\n            for(i=0; i<n && !dup; i++)\n                if(mask & (1 << i)) {\n                    if(small == -1)\n                        small = nums[i];\n                    if(big == nums[i])\n                        dup = true;\n                    big = nums[i];\n                }\n            \n            // If no duplicates were found, then calculate and store the range for this subset\n            if(!dup)\n                range[mask] = big - small;\n        }\n        \n        vector<int> dp(1 << n, INF);\n        dp[0] = 0;\n\n        // Iterate over every mask (i.e. subset) and calculate its minimum sum\n        for(int mask = 1; mask < (1 << n); mask++) {\n            \n            // Iterate over every submask for current mask\n            for(int submask = mask; submask; submask = (submask - 1) & mask) {\n                \n                // Check that submask has the right number of elements\n                if(__builtin_popcount(submask) == subset_size) \n                    // Note that      mask = submask + (mask ^ submask)\n                    // ==> i.e.,      mask ^ submask = mask - submask\n                    // In other words, (mask ^ submask) represents those elements in mask that are not in submask\n                    dp[mask] = min(dp[mask], range[submask] + dp[mask ^ submask]);\n            }\n        }\n\t\t// dp.back() == dp[(1 << n) - 1];\n        return dp.back() >= INF ? -1 : dp.back();\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111","title_slug":"minimum-incompatibility"}