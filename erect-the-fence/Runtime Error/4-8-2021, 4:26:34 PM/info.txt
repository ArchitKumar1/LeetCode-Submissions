{"id":478078216,"lang":"cpp","time":"8 months, 2 weeks","timestamp":1617879394,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/478078216/","is_pending":"Not Pending","title":"Erect the Fence","memory":"N/A","code":"class Solution {\npublic:\n    #define all(x) begin(x), end(x)\n    #define sz(x) (int)(x).size()\n    typedef long long ll;\n    template <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n    template<class T>\n    struct Point {\n        typedef Point P;\n        T x, y;\n        explicit Point(T x=0, T y=0) : x(x), y(y) {}\n        bool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }\n        bool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }\n        P operator+(P p) const { return P(x+p.x, y+p.y); }\n        P operator-(P p) const { return P(x-p.x, y-p.y); }\n        P operator*(T d) const { return P(x*d, y*d); }\n        P operator/(T d) const { return P(x/d, y/d); }\n        T dot(P p) const { return x*p.x + y*p.y; }\n        T cross(P p) const { return x*p.y - y*p.x; }\n        T cross(P a, P b) const { return (a-*this).cross(b-*this); }\n        T dist2() const { return x*x + y*y; }\n        double dist() const { return sqrt((double)dist2()); }\n        // angle to x-axis in interval [-pi, pi]\n        double angle() const { return atan2(y, x); }\n        P unit() const { return *this/dist(); } // makes dist()=1\n        P perp() const { return P(-y, x); } // rotates +90 degrees\n        P normal() const { return perp().unit(); }\n        // returns point rotated 'a' radians ccw around the origin\n        P rotate(double a) const {\n            return P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n        friend ostream& operator<<(ostream& os, P p) {\n            return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    };\n    typedef Point<ll> P;\n    vector<P> convexHull(vector<P> pts) {\n        if (pts.size() <= 1) return pts;\n        sort(all(pts));\n        vector<P> h(sz(pts)+1);\n        int s = 0, t = 0;\n        for (int it = 2; it--; s = --t, reverse(all(pts)))\n            for (P p : pts) {\n                while (t >= s + 2 && h[t-2].cross(h[t-1], p) < 0) t--;\n                h[t++] = p;\n            }\n        return {h.begin(), h.begin() + t - (t == 2 && h[0] == h[1])};\n    }\n    vector<vector<int>> outerTrees(vector<vector<int>>& points) {\n        int n = points.size();\n        vector<P> pts;\n        for(auto x :points ){\n            pts.push_back(P(x[0],x[1]));\n        }\n        vector<P> res = convexHull(pts);\n        vector<vector<int>>ans;\n        for(auto a: res){\n            cout << a.x << \" \" << a.y << endl;\n            ans.push_back({(int)a.x,(int)a.y});\n        }\n        return ans;\n    }\n};","compare_result":"100000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"erect-the-fence"}