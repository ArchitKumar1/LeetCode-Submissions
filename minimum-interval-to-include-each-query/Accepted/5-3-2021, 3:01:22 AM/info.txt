{"id":488036507,"lang":"cpp","time":"7 months, 3 weeks","timestamp":1619991082,"status_display":"Accepted","runtime":"580 ms","url":"/submissions/detail/488036507/","is_pending":"Not Pending","title":"Minimum Interval to Include Each Query","memory":"151.2 MB","code":"class Solution {\npublic:\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\n        int n = intervals.size();\n        int m = queries.size();        \n        vector<int> order(m);\n        \n        iota(order.begin(),order.end(),0);\n        sort(order.begin(),order.end(),[&](int &a, int &b){\n            return queries[a] < queries[b];\n        });\n        vector<int> res(m);\n             \n        vector<array<int,3>> st,en;\n        \n        int i = 0 ;\n        for(auto x : intervals){\n            int len = x[1] - x[0] + 1;\n            st.push_back({x[0],i,len});\n            en.push_back({x[1],i,len});\n            i++;\n        }\n        sort(st.begin(),st.end());\n        sort(en.begin(),en.end());\n        \n        multiset<int> vals;\n        int x = 0,y = 0;\n        for(int i = 0 ; i < queries.size();i++){\n            int q = queries[order[i]];\n            // Add startings\n            while( x < n && st[x][0] <= q){\n                vals.insert(st[x][2]);\n                x++;\n            }\n            while( y < n && en[y][0] < q){\n                vals.erase(vals.find(en[y][2]));\n                y++;\n            }\n            res[order[i]] = (vals.size() > 0 ? *vals.begin() : -1);\n            // Remove endings\n            \n        }\n        \n        return res;\n    }\n};","compare_result":"111111111111111111111111111111111111111111","title_slug":"minimum-interval-to-include-each-query"}