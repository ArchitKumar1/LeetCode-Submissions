{"id":487711188,"lang":"cpp","time":"7 months, 3 weeks","timestamp":1619927537,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/487711188/","is_pending":"Not Pending","title":"Minimum Interval to Include Each Query","memory":"N/A","code":"class Solution {\npublic:\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\n        int n = intervals.size();\n        int m = queries.size();\n        vector<array<int,4>> v;\n        int i =0;\n        v.reserve(2*n);\n        for(auto x : intervals){\n            v.push_back({x[0],-1,x[1]-x[0]+1});\n            v.push_back({x[1],1,x[1]-x[0]+1});\n            i++;\n        }\n        sort(v.begin(),v.end());\n        vector<array<int,2>> q;\n        q.reserve(2*m);\n        i =0;\n        map<int,int> m1;\n        for(auto x : queries){\n            q.push_back({x, i});\n            m1[x] = i;\n            i++;\n        }\n        sort(q.begin(),q.end());\n        \n        vector<int> res(m,INT_MAX);\n        \n        int backans = 0;\n        int backval = 0;\n        \n        \n        multiset<int> range_min;\n        \n        int j = 0;\n        for(auto x : v){\n            int t = x[1];\n            int v = x[0];\n           // cout << x[0] << endl;\n            int rangelen = x[2];\n            \n            while(j < m && q[j][0] < v && q[j][0] >= backval){\n              //  cout << q[j][0] << \" \" << x[0] << \" \" << x[1] << \" \" << x[2] <<  \" \" << backans << endl;\n                res[q[j][1]] = min(res[q[j][1]],backans);\n                j++;\n            }\n            if(m1.find(v)!= m1.end() && range_min.size() > 0){\n              //  cout << v << \" E \" << res[m1[v]] <<  \" \" << *range_min.begin() << endl;\n                res[m1[v]] = min(res[m1[v]],*range_min.begin());\n            }\n            if(t == -1){\n              //  cout << \"Insert \"<< x[0] << \" \" << x[1] << \" \" << x[2]  << endl;\n\n                range_min.insert(rangelen);\n            }else{\n              //  cout << \"Erase \"<< x[0] << \" \" << x[1] << \" \" << x[2]  << endl;\n                range_min.erase(range_min.find(rangelen));\n            }\n            // extra check \n            if(m1.find(v)!= m1.end() && range_min.size() > 0){\n              //   cout << v << \" E \" << res[m1[v]] <<  \" \" << *range_min.begin() << endl;\n                res[m1[v]] = min(res[m1[v]],*range_min.begin());\n            }\n            backans = *range_min.begin();\n           //  cout << backans << \" \" << backval << endl;;\n            backval = v;\n        }\n        for(int i = 0; i < m;i++){\n            if(res[i] == 0) res[i] = -1;\n        }\n        return res;\n    }\n};","compare_result":"111111010000000000000000000000001010000010","title_slug":"minimum-interval-to-include-each-query"}