{"id":441025673,"lang":"cpp","time":"11 months, 2 weeks","timestamp":1610259617,"status_display":"Accepted","runtime":"864 ms","url":"/submissions/detail/441025673/","is_pending":"Not Pending","title":"Minimize Hamming Distance After Swap Operations","memory":"152.3 MB","code":"class dsu {\n    public:\n    vector<int> par;\n    int n;\n    dsu(int _n) : n(_n) {\n        par.resize(n);\n        iota(par.begin(), par.end(), 0);\n    } \n    inline int get(int x) {\n        return (x == par[x] ? x : (par[x] = get(par[x])));\n    }\n    inline bool merge(int x, int y) {\n        x = get(x);\n        y = get(y);\n        if (x != y) {\n            par[x] = y;\n            return true;\n        }\n        return false;\n    }\n};\nclass Solution {\npublic:\n    \n    \n    int minimumHammingDistance(vector<int>& source, vector<int>& target, vector<vector<int>>& allowedSwaps) {\n        \n        int n = source.size();\n        \n        dsu D(n);\n        \n        for(auto x : allowedSwaps){\n            D.merge(x[0],x[1]);\n        }\n        int fans = 0;\n        vector<vector<pair<int,int>>> G1(n);\n        for(int i = 0;i<n;i++){\n            int par = D.get(i);\n            G1[par].emplace_back(source[i],i);\n        }\n        \n        for(auto x : G1){\n            multiset<int> F,S;\n            for(auto p : x){\n                F.insert(p.first);\n                S.insert(target[p.second]);\n            }\n            for(auto it : S){\n                if(F.find(it) == F.end()){\n                    fans += 1;\n                }else{\n                    F.erase(F.find(it));\n                }\n            }\n        }\n        return fans;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimize-hamming-distance-after-swap-operations"}