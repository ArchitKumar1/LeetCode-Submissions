{"id":576344011,"lang":"cpp","time":"2Â months","timestamp":1635069620,"status_display":"Accepted","runtime":"548 ms","url":"/submissions/detail/576344011/","is_pending":"Not Pending","title":"Count Nodes With the Highest Score","memory":"164.7 MB","code":"class Solution {\npublic:\n    int countHighestScoreNodes(vector<int>& parents) {\n        int n = parents.size();\n        vector<vector<int>> G(n);\n        for(int i = 0; i < n;i++){\n            if(parents[i] == -1) continue;\n            G[parents[i]].push_back(i);\n        }\n        vector<int> sz(n);\n        \n        function<void(int,int)> dfs = [&](int s,int par) -> void{\n            sz[s] += 1;\n            for(int c : G[s]){\n                if(c == par)continue;\n                dfs(c,s);\n                sz[s] += sz[c];\n            }\n        };\n        dfs(0,0);\n        vector<int64_t> scores;\n        function<void(int,int)> dfs2 = [&](int s,int par) -> void{\n            // in out dp\n            int64_t prod = 1;\n            \n            int subtreesum = 1;\n            \n            for(int c : G[s]){\n                if(c == par)continue;\n                dfs2(c,s);\n                subtreesum += sz[c];\n                prod *= sz[c];\n            }\n            int outsum = n - subtreesum;\n            if(outsum == 0) outsum = 1;\n            prod = prod * outsum;\n            scores.push_back(prod);\n        };\n        dfs2(0,0);\n        for(int s : scores){\n            cout << s << \" \";\n        }\n        cout << endl;\n        int64_t maxi = *max_element(scores.begin(),scores.end());\n        int counts = count(scores.begin(),scores.end(),maxi);\n        return counts;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-nodes-with-the-highest-score"}