{"id":572206972,"lang":"cpp","time":"2 months, 1 week","timestamp":1634405456,"status_display":"Accepted","runtime":"672 ms","url":"/submissions/detail/572206972/","is_pending":"Not Pending","title":"The Time When the Network Becomes Idle","memory":"204.7 MB","code":"template<typename T>  using min_pq = priority_queue<T,vector<T>,greater<T>>;\nclass Solution {\npublic:\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\n        int n = patience.size();\n        int m = edges.size();\n        \n        vector<vector<int>> G(n);\n        for(auto e : edges){\n            int u = e[0],v = e[1];\n            G[u].push_back(v);\n            G[v].push_back(u);\n        }\n        vector<int> dist(n,1e9);\n        dist[0] = 0;\n        min_pq<pair<int,int>> pq;\n        pq.emplace(0,0);\n        while(pq.size()){\n            auto[d,u] = pq.top(); pq.pop();\n            for(int v : G[u]){\n                if(dist[v] > dist[u] + 1){\n                    dist[v] = dist[u] + 1;\n                    pq.emplace(dist[v],v);\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 1;i < n;i++){\n            int roundtrip = 2 * dist[i];\n            int rem = roundtrip % patience[i];\n            int last = -1;\n            if(rem > 0){\n                last = roundtrip - rem;\n            }else{\n                last = roundtrip - patience[i];\n            }\n            last += roundtrip;\n            ans = max(last,ans);\n        }\n        return ans + 1;\n        // 0 5 10\n        // patience = 3 \n        // 0 3 6 9 \n        // // closest point till message return + round trip\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111","title_slug":"the-time-when-the-network-becomes-idle"}